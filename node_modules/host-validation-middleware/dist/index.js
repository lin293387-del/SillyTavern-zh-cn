import net from "node:net";

//#region src/parseHostHeader.ts
/**
* This function assumes that the input is not malformed.
* This is because we only care about browser requests.
* Non-browser clients can send any value they want anyway.
*/
function extractHostNameFromHostHeader(hostHeader) {
	const trimmedHost = hostHeader.trim();
	if (trimmedHost[0] === "[") {
		const endIpv6 = trimmedHost.indexOf("]");
		if (endIpv6 < 0) return { type: "invalid" };
		return net.isIP(trimmedHost.slice(1, endIpv6)) === 6 ? { type: "ipv6" } : { type: "invalid" };
	}
	const colonPos = trimmedHost.indexOf(":");
	const hostname = colonPos === -1 ? trimmedHost : trimmedHost.slice(0, colonPos);
	if (net.isIP(hostname) === 4) return { type: "ipv4" };
	return {
		type: "hostname",
		value: hostname
	};
}

//#endregion
//#region src/isHostAllowed.ts
const isFileOrExtensionProtocolRE = /^(?:file|.+-extension):/i;
function isHostAllowedInternal(hostHeader, allowedHosts) {
	if (isFileOrExtensionProtocolRE.test(hostHeader)) return true;
	const extracted = extractHostNameFromHostHeader(hostHeader);
	if (extracted.type === "invalid") return false;
	if (extracted.type === "ipv4" || extracted.type === "ipv6") return true;
	const hostname = extracted.value;
	if (hostname === "localhost" || hostname.endsWith(".localhost")) return true;
	for (const allowedHost of allowedHosts) {
		if (allowedHost === hostname) return true;
		if (allowedHost[0] === "." && (allowedHost.slice(1) === hostname || hostname.endsWith(allowedHost))) return true;
	}
	return false;
}
const cache = new WeakMap();
/**
* Check if the host contained in the host header is allowed.
*
* This function will cache the result if the `allowedHosts` array is frozen.
*
* @param hostHeader - The value of host header. See [RFC 9110 7.2](https://datatracker.ietf.org/doc/html/rfc9110#name-host-and-authority).
* @param allowedHosts - The allowed host patterns. See the README for more details.
*/
function isHostAllowed(hostHeader, allowedHosts) {
	if (hostHeader === void 0) return true;
	let cachedAllowedHosts;
	if (Object.isFrozen(allowedHosts)) {
		if (!cache.has(allowedHosts)) cache.set(allowedHosts, new Set());
		cachedAllowedHosts = cache.get(allowedHosts);
		if (cachedAllowedHosts.has(hostHeader)) return true;
	}
	const result = isHostAllowedInternal(hostHeader, allowedHosts);
	if (cachedAllowedHosts && result) cachedAllowedHosts.add(hostHeader);
	return result;
}

//#endregion
//#region src/middleware.ts
/**
* Middleware to validate the host header of incoming requests.
*
* If the host header is not in the allowed hosts list, a 403 Forbidden response
* is sent.
*/
function hostValidationMiddleware(options) {
	return async function hostValidationMiddleware$1(req, res, next) {
		const hostHeader = req.headers.host;
		if (!isHostAllowed(hostHeader, options.allowedHosts)) {
			const hostname = hostHeader?.replace(/:\d+$/, "") ?? "";
			const errorMessage = options.generateErrorMessage?.(hostname) ?? generateDefaultErrorMessage(hostname);
			res.writeHead(403, { "Content-Type": options.errorResponseContentType ?? "text/plain" });
			res.end(errorMessage);
			return;
		}
		next();
	};
}
function generateDefaultErrorMessage(hostname) {
	return `Blocked request. This host (${JSON.stringify(hostname)}) is not allowed.`;
}

//#endregion
export { hostValidationMiddleware, isHostAllowed };