import z from "zod";
declare const JpegOptionsSchema: z.ZodObject<{
    colorSpace: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"display-p3">, z.ZodLiteral<"srgb">]>>;
    jpegColorSpace: z.ZodUnion<[z.ZodLiteral<"rgb">, z.ZodLiteral<"grayscale">, z.ZodLiteral<"ycbcr">]>;
    /**
     * Image quality, between 0 and 100.
     * For lossy, 0 gives the smallest size and 100 the largest.
     * For lossless, this parameter is the amount of effort put
     * into the compression: 0 is the fastest but gives larger
     * files compared to the slowest, but best, 100.
     * @default 100
     */
    quality: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    arithmetic: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    autoSubsample: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    baseline: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    chromaQuality: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    chromaSubsample: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    optimizeCoding: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    progressive: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    quantTable: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    separateChromaQuality: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    smoothing: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    trellisLoops: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    trellisMultipass: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    trellisOptTable: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    trellisOptZero: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
    jpegColorSpace: "rgb" | "grayscale" | "ycbcr";
    quality: number;
    arithmetic: boolean;
    autoSubsample: boolean;
    baseline: boolean;
    chromaQuality: number;
    chromaSubsample: number;
    optimizeCoding: boolean;
    progressive: boolean;
    quantTable: number;
    separateChromaQuality: boolean;
    smoothing: number;
    trellisLoops: number;
    trellisMultipass: boolean;
    trellisOptTable: boolean;
    trellisOptZero: boolean;
    colorSpace?: "display-p3" | "srgb" | undefined;
}, {
    jpegColorSpace: "rgb" | "grayscale" | "ycbcr";
    colorSpace?: "display-p3" | "srgb" | undefined;
    quality?: number | undefined;
    arithmetic?: boolean | undefined;
    autoSubsample?: boolean | undefined;
    baseline?: boolean | undefined;
    chromaQuality?: number | undefined;
    chromaSubsample?: number | undefined;
    optimizeCoding?: boolean | undefined;
    progressive?: boolean | undefined;
    quantTable?: number | undefined;
    separateChromaQuality?: boolean | undefined;
    smoothing?: number | undefined;
    trellisLoops?: number | undefined;
    trellisMultipass?: boolean | undefined;
    trellisOptTable?: boolean | undefined;
    trellisOptZero?: boolean | undefined;
}>;
type JpegOptions = z.infer<typeof JpegOptionsSchema>;
export default function jpeg(): {
    mime: "image/jpeg";
    hasAlpha: true;
    encode: (bitmap: import("@jimp/types").Bitmap, options?: Partial<JpegOptions>) => Promise<Buffer>;
    decode: (data: Buffer) => Promise<{
        data: Buffer;
        width: number;
        height: number;
    }>;
};
export {};
//# sourceMappingURL=index.d.ts.map