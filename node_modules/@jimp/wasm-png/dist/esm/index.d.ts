import z from "zod";
declare const PngOptionsSchema: z.ZodObject<{
    colorSpace: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"display-p3">, z.ZodLiteral<"srgb">]>>;
    optimize: z.ZodOptional<z.ZodObject<{
        /** whether to use PNG interlacing or not. Interlacing will increase the size of an optimised image. */
        interlace: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
        /** is the optimisation level between 1 to 6. The higher the level, the higher the compression. Any level above 4 is not recommended. */
        level: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
        /** whether to allow transparent pixels to be altered to improve compression. */
        optimiseAlpha: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    }, "strip", z.ZodTypeAny, {
        interlace: boolean;
        level: number;
        optimiseAlpha: boolean;
    }, {
        interlace?: boolean | undefined;
        level?: number | undefined;
        optimiseAlpha?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    colorSpace?: "display-p3" | "srgb" | undefined;
    optimize?: {
        interlace: boolean;
        level: number;
        optimiseAlpha: boolean;
    } | undefined;
}, {
    colorSpace?: "display-p3" | "srgb" | undefined;
    optimize?: {
        interlace?: boolean | undefined;
        level?: number | undefined;
        optimiseAlpha?: boolean | undefined;
    } | undefined;
}>;
type PngOptions = z.infer<typeof PngOptionsSchema>;
export default function png(): {
    mime: "image/png";
    hasAlpha: true;
    encode: (bitmap: import("@jimp/types").Bitmap, options?: Partial<PngOptions>) => Promise<Buffer>;
    decode: (data: Buffer) => Promise<{
        data: Buffer;
        width: number;
        height: number;
    }>;
};
export {};
//# sourceMappingURL=index.d.ts.map